## 对称加密

加秘和解秘用同一个秘钥的加秘方式叫做对称加秘

会产生的问题

1.许多客户端不可能都用同一秘钥进行加秘,解决办法就是使用一个客户端使用一个密钥进行加密。

2.但是，随之产生的问题,加密的密钥如何传输，`一端生成一个秘钥，然后通过HTTP传输给另一端`

3.如果传输中被拦截，那么`密钥也会被获取`,如果对密钥再进行加密，那么`又怎么保存对密钥加密的过程`

## 非对称加密

- 有一对秘钥，`公钥`和`私钥`。
- 公钥加密的内容，只有私钥可以解开，私钥加密的内容，所有的公钥都可以解开，这里说的`公钥都可以解开，指的是一对秘钥`。
- 公钥可以发送给所有的客户端，私钥只保存在服务器端。

### 主要工作流程

<img :src="$withBase('/imgs/miyao.png')" alt="miyao">

### 步骤

1. Client 发起一个 HTTPS 请求，连接 443 端口。这个过程可以理解成是`请求公钥的过程`。

2. Server 端收到请求后，通过第三方机构私钥加密，会把数字证书（也可以认为是公钥证书）发送给 Client。

3.

- 浏览器安装后会自动带一些权威第三方机构公钥，使用匹配的公钥对数字签名进行解密。
- 根据签名生成的规则对网站信息进行本地签名生成，然后两者比对。
- 通过比对两者签名，匹配则说明认证通过，不匹配则获取证书失败。

4. 在安全拿到`服务器公钥`后，客户端 Client 随机生成一个`对称密钥`，使用`服务器公钥`（证书的公钥）加密这个`对称密钥`，发送给 Server(服务器)。

5. Server(服务器)通过自己的私钥，对信息解密，至此得到了`对称密钥`，此时两者都拥有了相同的`对称密钥`。

- Client 用户使用该`对称密钥`加密'明文内容 B',发送给 Server(服务器)

* Server 使用该`对称密钥`进行解密消息，得到明文内容 B。

如此，又会产生一个问题，`如果公钥被中间人拿到纂改怎么办?客户端可能拿到的公钥是假的，有什么解决办法？`

### 第三方认证

简单说，就是`通过某种规范可以让客户端和服务器都遵循某种约定`,即第三方认证。
在 HTTPS 中，通过 `证书`+`数字签名`来解决这个问题。

<img :src="$withBase('/imgs/disanfang.png')" alt="disanfang">

不同的是，假设对网站信息加密的算法是 MD5，通过 MD5 加密后，然后通过第三方机构的私钥再次对其加密，生成`数字签名`。

如此，数字证书包含有两个特别重要的信息 `某网站公钥+数字签名`

假设中间人截取到服务器的公钥后，去替换成自己的公钥，因为有数字签名的存在，这样子客户端验证发现数字签名不匹配，这样子就防止中间人替换公钥的问题。

- 浏览器会去安装一些比较权威的第三方认证机构的公钥，比如 VeriSign、Symantec 以及 GlobalSign 等等。

- 验证数字签名的时候，会直接从本地拿到相应的第三方的公钥，对私钥加密后的数字签名进行解密得到真正的签名。

* 然后客户端利用签名生成规则进行签名生成，看两个签名是否匹配，如果匹配认证通过，不匹配则获取证书失败。

### 数字签名的作用

将网站的信息，通过特定的算法加密，比如 MD5,加密之后，再通过服务器的私钥进行加密，形成`加密后的数字签名`。

第三方认证机构是一个公开的平台，中间人可以去获取。

如果没有数字签名的话，那么

<img :src="$withBase('/imgs/qianming.png')" alt="qianming">

如果`只是对网站信息进行第三方机构私钥加密`的话，还是会受到欺骗。

因为没有认证，所以中间人也向第三方认证机构进行申请，然后拦截后把所有的信息都替换成自己的，客户端仍然可以解密，并且无法判断这是服务器的还是中间人的，最后造成数据泄露。
